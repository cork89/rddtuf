// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"time"
)

const createApiKey = `-- name: CreateApiKey :one
INSERT INTO apikeys (
  user_id, apikey, created_dt_tm
) VALUES (
  ?, ?, ?
)
RETURNING id, user_id, apikey, created_dt_tm
`

type CreateApiKeyParams struct {
	UserID      int64
	Apikey      string
	CreatedDtTm time.Time
}

func (q *Queries) CreateApiKey(ctx context.Context, arg CreateApiKeyParams) (Apikey, error) {
	row := q.db.QueryRowContext(ctx, createApiKey, arg.UserID, arg.Apikey, arg.CreatedDtTm)
	var i Apikey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Apikey,
		&i.CreatedDtTm,
	)
	return i, err
}

const createRatelimit = `-- name: CreateRatelimit :one
INSERT INTO ratelimits (
  user_id, last_call_timestamp, call_count
) VALUES (
  ?, ?, ?
)
RETURNING id, user_id, last_call_timestamp, call_count
`

type CreateRatelimitParams struct {
	UserID            int64
	LastCallTimestamp time.Time
	CallCount         int64
}

func (q *Queries) CreateRatelimit(ctx context.Context, arg CreateRatelimitParams) (Ratelimit, error) {
	row := q.db.QueryRowContext(ctx, createRatelimit, arg.UserID, arg.LastCallTimestamp, arg.CallCount)
	var i Ratelimit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LastCallTimestamp,
		&i.CallCount,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  username, refresh_token, refresh_expire_dt_tm, access_token, icon_url, subscribed, subscription_dt_tm, remaining_uploads, upload_refresh_dt_tm
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, username, refresh_token, refresh_expire_dt_tm, access_token, icon_url, subscribed, subscription_dt_tm, remaining_uploads, upload_refresh_dt_tm
`

type CreateUserParams struct {
	Username          string
	RefreshToken      string
	RefreshExpireDtTm time.Time
	AccessToken       string
	IconUrl           string
	Subscribed        bool
	SubscriptionDtTm  time.Time
	RemainingUploads  int64
	UploadRefreshDtTm time.Time
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Username,
		arg.RefreshToken,
		arg.RefreshExpireDtTm,
		arg.AccessToken,
		arg.IconUrl,
		arg.Subscribed,
		arg.SubscriptionDtTm,
		arg.RemainingUploads,
		arg.UploadRefreshDtTm,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.RefreshToken,
		&i.RefreshExpireDtTm,
		&i.AccessToken,
		&i.IconUrl,
		&i.Subscribed,
		&i.SubscriptionDtTm,
		&i.RemainingUploads,
		&i.UploadRefreshDtTm,
	)
	return i, err
}

const deleteApiKey = `-- name: DeleteApiKey :exec
DELETE FROM apikeys
WHERE user_id = ?
`

func (q *Queries) DeleteApiKey(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteApiKey, userID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
where id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getApikeyByUserId = `-- name: GetApikeyByUserId :one
SELECT id, user_id, apikey, created_dt_tm FROM apikeys
WHERE user_id=? LIMIT 1
`

func (q *Queries) GetApikeyByUserId(ctx context.Context, userID int64) (Apikey, error) {
	row := q.db.QueryRowContext(ctx, getApikeyByUserId, userID)
	var i Apikey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Apikey,
		&i.CreatedDtTm,
	)
	return i, err
}

const getRatelimitByUserID = `-- name: GetRatelimitByUserID :one
SELECT id, user_id, last_call_timestamp, call_count FROM ratelimits
WHERE user_id=? LIMIT 1
`

func (q *Queries) GetRatelimitByUserID(ctx context.Context, userID int64) (Ratelimit, error) {
	row := q.db.QueryRowContext(ctx, getRatelimitByUserID, userID)
	var i Ratelimit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LastCallTimestamp,
		&i.CallCount,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, username, refresh_token, refresh_expire_dt_tm, access_token, icon_url, subscribed, subscription_dt_tm, remaining_uploads, upload_refresh_dt_tm FROM users
WHERE id=? LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.RefreshToken,
		&i.RefreshExpireDtTm,
		&i.AccessToken,
		&i.IconUrl,
		&i.Subscribed,
		&i.SubscriptionDtTm,
		&i.RemainingUploads,
		&i.UploadRefreshDtTm,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, refresh_token, refresh_expire_dt_tm, access_token, icon_url, subscribed, subscription_dt_tm, remaining_uploads, upload_refresh_dt_tm FROM users
WHERE username=? LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.RefreshToken,
		&i.RefreshExpireDtTm,
		&i.AccessToken,
		&i.IconUrl,
		&i.Subscribed,
		&i.SubscriptionDtTm,
		&i.RemainingUploads,
		&i.UploadRefreshDtTm,
	)
	return i, err
}

const getUserIdByApikey = `-- name: GetUserIdByApikey :one
SELECT user_id FROM apikeys
WHERE apikey=? LIMIT 1
`

func (q *Queries) GetUserIdByApikey(ctx context.Context, apikey string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserIdByApikey, apikey)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const updateApiKey = `-- name: UpdateApiKey :one
UPDATE apikeys
SET apikey = ?, created_dt_tm = ?
WHERE user_id = ?
RETURNING id, user_id, apikey, created_dt_tm
`

type UpdateApiKeyParams struct {
	Apikey      string
	CreatedDtTm time.Time
	UserID      int64
}

func (q *Queries) UpdateApiKey(ctx context.Context, arg UpdateApiKeyParams) (Apikey, error) {
	row := q.db.QueryRowContext(ctx, updateApiKey, arg.Apikey, arg.CreatedDtTm, arg.UserID)
	var i Apikey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Apikey,
		&i.CreatedDtTm,
	)
	return i, err
}

const updateRatelimit = `-- name: UpdateRatelimit :one
UPDATE ratelimits
SET last_call_timestamp = ?, call_count = ?
WHERE user_id = ?
RETURNING id, user_id, last_call_timestamp, call_count
`

type UpdateRatelimitParams struct {
	LastCallTimestamp time.Time
	CallCount         int64
	UserID            int64
}

func (q *Queries) UpdateRatelimit(ctx context.Context, arg UpdateRatelimitParams) (Ratelimit, error) {
	row := q.db.QueryRowContext(ctx, updateRatelimit, arg.LastCallTimestamp, arg.CallCount, arg.UserID)
	var i Ratelimit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LastCallTimestamp,
		&i.CallCount,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET access_token = ?, refresh_expire_dt_tm = ?
WHERE id = ?
RETURNING id, username, refresh_token, refresh_expire_dt_tm, access_token, icon_url, subscribed, subscription_dt_tm, remaining_uploads, upload_refresh_dt_tm
`

type UpdateUserParams struct {
	AccessToken       string
	RefreshExpireDtTm time.Time
	ID                int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser, arg.AccessToken, arg.RefreshExpireDtTm, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.RefreshToken,
		&i.RefreshExpireDtTm,
		&i.AccessToken,
		&i.IconUrl,
		&i.Subscribed,
		&i.SubscriptionDtTm,
		&i.RemainingUploads,
		&i.UploadRefreshDtTm,
	)
	return i, err
}
